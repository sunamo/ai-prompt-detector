import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';

let outputChannel: vscode.OutputChannel;
let recentPrompts: string[] = [];
let aiPromptCounter: number = 0;
let statusBarItem: vscode.StatusBarItem;

// Logging system
const LOG_DIR = 'C:\\temp\\ai-prompt-detector-logs';

function ensureLogDir(): void {
	try {
		if (!fs.existsSync(LOG_DIR)) {
			fs.mkdirSync(LOG_DIR, { recursive: true });
		}
	} catch (error) {
		console.error('Failed to create log directory:', error);
	}
}

function writeLog(message: string, isDebug: boolean = false): void {
	const timestamp = new Date().toISOString();
	const logMessage = `[${timestamp}] ${message}`;
	
	if (outputChannel) {
		outputChannel.appendLine(logMessage);
	}
	
	const config = vscode.workspace.getConfiguration('ai-prompt-detector');
	const debugEnabled = config.get<boolean>('enableDebugLogs', false);
	
	if (!isDebug || debugEnabled) {
		try {
			ensureLogDir();
			const logFile = path.join(LOG_DIR, `extension-${new Date().toISOString().split('T')[0]}.log`);
			fs.appendFileSync(logFile, logMessage + '\n', 'utf8');
		} catch (error) {
			console.error('Failed to write to log file:', error);
		}
	}
}

// Auto-save configuration
const AUTO_SAVE_ENABLED = true;
const AUTO_SAVE_INTERVAL = 5000;
const AUTO_SAVE_PATTERNS = ['**/*.md', '**/*.txt', '**/*.json'];
let autoSaveTimer: NodeJS.Timeout | undefined;

function isValidSpecStoryFile(filePath: string): boolean {
	try {
		const fileName = path.basename(filePath);
		const specStoryPattern = /^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}Z-.+\.md$/;
		if (!specStoryPattern.test(fileName)) {
			return false;
		}
		
		if (!fs.existsSync(filePath)) {
			return false;
		}
		
		const content = fs.readFileSync(filePath, 'utf8');
		return content.includes('<!-- Generated by SpecStory -->') || 
		       content.includes('_**User**_') || 
		       content.includes('_**Assistant**_');
	} catch (error) {
		return false;
	}
}

function extractPromptsFromContent(content: string): string[] {
	const prompts: string[] = [];
	
	try {
		const sections = content.split(/(?=_\*\*User\*\*_|_\*\*Assistant\*\*_)/);
		
		for (let i = 0; i < sections.length; i++) {
			const section = sections[i];
			if (section.includes('_**User**_')) {
				const lines = section.split('\n');
				const userPrompt: string[] = [];
				let foundUserMarker = false;
				
				for (const line of lines) {
					if (line.includes('_**User**_')) {
						foundUserMarker = true;
						continue;
					}
					
					if (foundUserMarker) {
						if (line.includes('---') || line.includes('_**Assistant**_')) {
							break;
						}
						
						const trimmedLine = line.trim();
						if (trimmedLine) {
							userPrompt.push(trimmedLine);
						}
					}
				}
				
				if (userPrompt.length > 0) {
					const fullPrompt = userPrompt.join(' ').trim();
					if (fullPrompt.length > 0) {
						prompts.push(fullPrompt);
					}
				}
			}
		}
		
		return prompts.reverse();
		
	} catch (error) {
		writeLog(`Error extracting prompts: ${error}`, false);
	}
	
	return prompts;
}

function loadPromptsFromFile(filePath: string): void {
	try {
		const content = fs.readFileSync(filePath, 'utf8');
		const extractedPrompts = extractPromptsFromContent(content);
		
		extractedPrompts.forEach(prompt => {
			recentPrompts.push(prompt);
		});
		
		writeLog(`üìÅ Loaded ${extractedPrompts.length} prompts from ${path.basename(filePath)}`, false);
	} catch (error) {
		writeLog(`Error loading prompts from file: ${error}`, false);
	}
}

class PromptsProvider implements vscode.WebviewViewProvider {
	public static readonly viewType = 'ai-prompt-detector-view';
	private _view?: vscode.WebviewView;

	constructor() {
		writeLog('üéØ PROMPTS: Provider created', true);
	}

	public resolveWebviewView(
		webviewView: vscode.WebviewView,
		context: vscode.WebviewViewResolveContext,
		_token: vscode.CancellationToken,
	) {
		writeLog('üéØ PROMPTS: resolveWebviewView called', true);
		
		this._view = webviewView;
		
		webviewView.webview.options = {
			enableScripts: false,
			localResourceRoots: []
		};

		this.updateWebview();
		
		writeLog('üéØ PROMPTS: Real prompts set', true);
		writeLog('üéØ PROMPTS: Showing real prompts from SpecStory files', false);
		writeLog(`üéØ PROMPTS: Number of prompts to display: ${recentPrompts.length}`, false);
	}

	public refresh(): void {
		if (this._view) {
			this.updateWebview();
		}
	}

	private updateWebview(): void {
		if (!this._view) {
			writeLog('üéØ PROMPTS: Webview not ready yet', true);
			return;
		}
		
		const html = this.createPromptsHtml();
		this._view.webview.html = html;
		
		writeLog(`üéØ PROMPTS: HTML set, displaying ${recentPrompts.length} prompts`, true);
	}

	private createPromptsHtml(): string {
		let promptsHtml = '';
		
		const config = vscode.workspace.getConfiguration('ai-prompt-detector');
		const maxPrompts = config.get<number>('maxPrompts', 50);
		
		if (recentPrompts.length > 0) {
			const displayPrompts = recentPrompts.slice(0, maxPrompts);
			
			promptsHtml = displayPrompts.map((prompt, index) => {
				const shortPrompt = prompt.length > 150 ? prompt.substring(0, 150) + '...' : prompt;
				
				const safePrompt = shortPrompt
					.replace(/&/g, '&amp;')
					.replace(/</g, '&lt;')
					.replace(/>/g, '&gt;')
					.replace(/"/g, '&quot;');
				
				return `
<div class="prompt-item">
	<div class="prompt-number">#${index + 1}</div>
	<div class="prompt-text">${safePrompt}</div>
</div>`;
			}).join('');
		} else {
			promptsHtml = `
<div class="no-prompts">
	<p>üîç No SpecStory prompts found</p>
	<p>Create a SpecStory conversation to display prompts</p>
</div>`;
		}

	const extensionVersion = vscode.extensions.getExtension('sunamocz.ai-prompt-detector')?.packageJSON.version || '1.1.79';

	return `<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>SpecStory Prompts</title>
	<style>
		body {
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
			background-color: #1e1e1e;
			color: #cccccc;
			margin: 0;
			padding: 8px;
			font-size: 12px;
			line-height: 1.4;
		}
		.prompt-item {
			background-color: #252526;
			border: 1px solid #3c3c3c;
			border-left: 4px solid #007acc;
			margin: 6px 0;
			padding: 8px;
			border-radius: 3px;
			transition: background-color 0.2s;
		}
		.prompt-item:hover {
			background-color: #2d2d30;
		}
		.prompt-number {
			font-weight: bold;
			color: #569cd6;
			margin-bottom: 4px;
			font-size: 11px;
		}
		.prompt-text {
			color: #d4d4d4;
			font-size: 11px;
			line-height: 1.3;
			word-wrap: break-word;
		}
		.no-prompts {
			text-align: center;
			padding: 20px;
			color: #888;
		}
		.header-bar {
			margin-bottom: 15px;
			padding: 8px;
			background-color: #0e639c;
			border-radius: 3px;
			text-align: center;
			color: white;
			font-size: 10px;
		}
	</style>
</head>
<body>

<div class="header-bar">
	üìä Total: ${recentPrompts.length} prompts (max ${maxPrompts}) | ‚öôÔ∏è Change max count in settings
</div>

${promptsHtml}

</body>
</html>`;
	}
}

export async function activate(context: vscode.ExtensionContext) {
	writeLog('üöÄ ACTIVATION: Extension starting...', true);
	
	outputChannel = vscode.window.createOutputChannel('SpecStory Prompts');
	outputChannel.show();
	writeLog('üöÄ PROMPTS: Extension starting...', false);
	
	statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
	statusBarItem.show();
	
	const updateStatusBar = () => {
		const extensionVersion = vscode.extensions.getExtension('sunamocz.ai-prompt-detector')?.packageJSON.version || '1.1.79';
		statusBarItem.text = `ü§ñ AI Prompts: ${aiPromptCounter} | v${extensionVersion}`;
		statusBarItem.tooltip = 'AI Prompt Detector + AI Copilot Prompt Detection';
	};
	updateStatusBar();
	
	await loadExistingPrompts();
	writeLog(`üöÄ PROMPTS: After loading we have ${recentPrompts.length} prompts`, false);
	
	const promptsProvider = new PromptsProvider();
	
	writeLog(`üöÄ PROMPTS: Registering provider with viewType: ${PromptsProvider.viewType}`, true);
	const registration = vscode.window.registerWebviewViewProvider(
		PromptsProvider.viewType,
		promptsProvider
	);
	
	writeLog('üöÄ PROMPTS: Provider registered successfully', false);
	
	const watcher = vscode.workspace.createFileSystemWatcher('**/.specstory/history/*.md');
	
	watcher.onDidCreate(uri => {
		if (isValidSpecStoryFile(uri.fsPath)) {
			writeLog(`üìù New SpecStory file: ${path.basename(uri.fsPath)}`, false);
			loadPromptsFromFile(uri.fsPath);
			promptsProvider.refresh();
		}
	});

	const configWatcher = vscode.workspace.onDidChangeConfiguration(e => {
		if (e.affectsConfiguration('ai-prompt-detector.maxPrompts')) {
			const config = vscode.workspace.getConfiguration('ai-prompt-detector');
			const maxPrompts = config.get<number>('maxPrompts', 50);
			writeLog(`‚öôÔ∏è Settings changed: maxPrompts = ${maxPrompts}`, false);
			promptsProvider.refresh();
		}
	});

	// Improved Copilot prompt detection via TextDocument changes
	const textDocumentWatcher = vscode.workspace.onDidChangeTextDocument(e => {
		try {
			const changes = e.contentChanges;
			for (const change of changes) {
				const text = change.text;
				
				// Better prompt detection patterns
				if (text.length > 10 && (
					text.toLowerCase().includes('explain') ||
					text.toLowerCase().includes('help me') ||
					text.toLowerCase().includes('generate') ||
					text.toLowerCase().includes('create') ||
					text.toLowerCase().includes('fix') ||
					text.toLowerCase().includes('debug') ||
					text.toLowerCase().includes('how to') ||
					text.toLowerCase().includes('what is') ||
					text.includes('?') ||
					(text.length > 30 && text.trim().split(' ').length > 5)
				)) {
					writeLog(`üîç POTENTIAL AI PROMPT: "${text.substring(0, 50)}..."`, true);
					
					setTimeout(() => {
						const editor = vscode.window.activeTextEditor;
						if (editor && editor.document === e.document) {
							const currentLine = editor.document.lineAt(editor.selection.active.line);
							const lineText = currentLine.text.trim();
							if (lineText.length > 15) {
								processPotentialPrompt(lineText);
							}
						}
					}, 500); // Longer delay to capture complete input
				}
			}
		} catch (error) {
			writeLog(`‚ùå Error in text watcher: ${error}`, false);
		}
	});

	function processPotentialPrompt(promptText: string) {
		try {
			const cleanPrompt = promptText.trim();
			if (cleanPrompt.length < 15 || cleanPrompt.length > 1000) {
				return;
			}
			
			if (recentPrompts.includes(cleanPrompt)) {
				writeLog(`üîÑ DUPLICATE PROMPT: "${cleanPrompt.substring(0, 30)}..."`, true);
				return;
			}
			
			aiPromptCounter++;
			writeLog(`ü§ñ NEW AI PROMPT DETECTED! Counter: ${aiPromptCounter}`, false);
			writeLog(`üìù PROMPT: "${cleanPrompt}"`, false);
			
			const config = vscode.workspace.getConfiguration('ai-prompt-detector');
			const customMessage = config.get<string>('customMessage', '');
			
			const notificationMessage = customMessage 
				? `AI Prompt detected\n${customMessage}`
				: 'AI Prompt detected\nCheck: Quality & accuracy of response';
			
			vscode.window.showInformationMessage(notificationMessage);
			writeLog(`üì¢ NOTIFICATION SHOWN: ${notificationMessage.replace('\n', ' | ')}`, false);
			
			recentPrompts.unshift(cleanPrompt);
			writeLog(`‚ûï PROMPT ADDED TO ACTIVITY BAR: "${cleanPrompt.substring(0, 50)}..."`, false);
			
			if (recentPrompts.length > 1000) {
				recentPrompts = recentPrompts.slice(0, 1000);
				writeLog(`üîÑ TRIMMED PROMPTS ARRAY TO 1000 ITEMS`, true);
			}
			
			updateStatusBar();
			promptsProvider.refresh();
			writeLog(`üîÑ UI UPDATED`, true);
			
		} catch (error) {
			writeLog(`‚ùå Error processing prompt: ${error}`, false);
		}
	}

	// Auto-save functionality
	if (AUTO_SAVE_ENABLED) {
		writeLog(`üíæ AUTO-SAVE: Enabled with interval ${AUTO_SAVE_INTERVAL}ms`, false);
		writeLog(`üíæ AUTO-SAVE: Patterns: ${AUTO_SAVE_PATTERNS.join(', ')}`, false);
		
		const startAutoSave = () => {
			if (autoSaveTimer) {
				clearInterval(autoSaveTimer);
			}
			
			autoSaveTimer = setInterval(async () => {
				try {
					const dirtyEditors = vscode.window.visibleTextEditors.filter(editor => 
						editor.document.isDirty && 
						AUTO_SAVE_PATTERNS.some(pattern => 
							editor.document.fileName.includes('.md') || 
							editor.document.fileName.includes('.txt') || 
							editor.document.fileName.includes('.json')
						)
					);
					
					if (dirtyEditors.length > 0) {
						writeLog(`üíæ AUTO-SAVE: Saving ${dirtyEditors.length} dirty files`, true);
						
						for (const editor of dirtyEditors) {
							await editor.document.save();
							writeLog(`üíæ AUTO-SAVE: Saved ${path.basename(editor.document.fileName)}`, true);
						}
					}
				} catch (error) {
					writeLog(`‚ùå AUTO-SAVE: Error saving files: ${error}`, false);
				}
			}, AUTO_SAVE_INTERVAL);
		};
		
		startAutoSave();
	}
	
	context.subscriptions.push(outputChannel, registration, watcher, configWatcher, textDocumentWatcher, statusBarItem);
	
	context.subscriptions.push({
		dispose: () => {
			if (autoSaveTimer) {
				clearInterval(autoSaveTimer);
				autoSaveTimer = undefined;
				writeLog('üíæ AUTO-SAVE: Timer cleared', false);
			}
		}
	});
	
	writeLog(`üöÄ PROMPTS: Activation complete - total ${recentPrompts.length} prompts`, false);
	writeLog('üöÄ PROMPTS: Open Activity Bar panel SpecStory AI!', false);
}

async function loadExistingPrompts(): Promise<void> {
	try {
		writeLog('üîç Searching for existing SpecStory files...', false);
		
		const files = await vscode.workspace.findFiles('**/.specstory/history/*.md');
		writeLog(`üìä Found ${files.length} SpecStory files`, false);
		
		if (files.length > 0) {
			const sortedFiles = files.sort((a, b) => {
				const nameA = path.basename(a.fsPath);
				const nameB = path.basename(b.fsPath);
				return nameB.localeCompare(nameA);
			});
			
			sortedFiles.forEach(file => {
				if (isValidSpecStoryFile(file.fsPath)) {
					loadPromptsFromFile(file.fsPath);
				}
			});
			
			writeLog(`‚úÖ Total loaded ${recentPrompts.length} prompts from ${sortedFiles.length} files`, false);
		} else {
			writeLog('‚ÑπÔ∏è No SpecStory files found', false);
			recentPrompts.push('Welcome to AI Prompt Detector + AI Copilot Prompt Detection');
			recentPrompts.push('TEST: Dummy prompt for demonstration');
			writeLog('üéØ Added test prompts for demonstration', false);
		}
	} catch (error) {
		writeLog(`‚ùå Error loading prompts: ${error}`, false);
	}
}

export function deactivate() {
	writeLog('üöÄ DEACTIVATION: Extension shutting down', false);
	
	if (autoSaveTimer) {
		clearInterval(autoSaveTimer);
		autoSaveTimer = undefined;
	}
	
	writeLog('üíæ AUTO-SAVE: Extension deactivated, timer cleared', false);
	writeLog('üöÄ Extension deactivated', false);
}
