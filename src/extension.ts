import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';

let outputChannel: vscode.OutputChannel;
let recentPrompts: string[] = [];

// Funkce pro validaci SpecStory soubor≈Ø
function isValidSpecStoryFile(filePath: string): boolean {
	try {
		const fileName = path.basename(filePath);
		// Check if filename matches SpecStory pattern: YYYY-MM-DD_HH-mmZ-*.md
		const specStoryPattern = /^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}Z-.+\.md$/;
		if (!specStoryPattern.test(fileName)) {
			return false;
		}
		
		// Check if file exists and contains SpecStory markers
		if (!fs.existsSync(filePath)) {
			return false;
		}
		
		const content = fs.readFileSync(filePath, 'utf8');
		return content.includes('<!-- Generated by SpecStory -->') || 
		       content.includes('_**User**_') || 
		       content.includes('_**Assistant**_');
	} catch (error) {
		return false;
	}
}

// Funkce pro extrakci prompt≈Ø ze SpecStory obsahu
function extractPromptsFromContent(content: string): string[] {
	const prompts: string[] = [];
	
	try {
		// Split content by user/assistant markers
		const sections = content.split(/(?=_\*\*User\*\*_|_\*\*Assistant\*\*_)/);
		
		for (let i = 0; i < sections.length; i++) {
			const section = sections[i];
			// Look for user sections
			if (section.includes('_**User**_')) {
				// Extract text after the user marker
				const lines = section.split('\n');
				const userPrompt: string[] = [];
				let foundUserMarker = false;
				
				for (const line of lines) {
					if (line.includes('_**User**_')) {
						foundUserMarker = true;
						continue;
					}
					
					if (foundUserMarker) {
						// Stop at separator or assistant marker
						if (line.includes('---') || line.includes('_**Assistant**_')) {
							break;
						}
						
						// Add non-empty lines to prompt
						const trimmedLine = line.trim();
						if (trimmedLine) {
							userPrompt.push(trimmedLine);
						}
					}
				}
				
				// Join the prompt lines and add if not empty
				if (userPrompt.length > 0) {
					const fullPrompt = userPrompt.join(' ').trim();
					if (fullPrompt.length > 0) {
						prompts.push(fullPrompt);
					}
				}
			}
		}
		
		// Reverse prompts so newest prompts in file come first
		return prompts.reverse();
		
	} catch (error) {
		console.error('Error extracting prompts:', error);
	}
	
	return prompts;
}

// Funkce pro naƒçten√≠ prompt≈Ø ze souboru
function loadPromptsFromFile(filePath: string): void {
	try {
		const content = fs.readFileSync(filePath, 'utf8');
		const extractedPrompts = extractPromptsFromContent(content);
		
		// Add all prompts from this file
		extractedPrompts.forEach(prompt => {
			recentPrompts.push(prompt);
		});
		
		if (outputChannel) {
			outputChannel.appendLine(`üìÅ Loaded ${extractedPrompts.length} prompts from ${path.basename(filePath)}`);
		}
	} catch (error) {
		console.error('Error loading prompts from file:', error);
	}
}

// ACTIVITY BAR PROVIDER S RE√ÅLN√ùMI PROMPTY
class PromptsProvider implements vscode.WebviewViewProvider {
	public static readonly viewType = 'specstory-autosave-view';
	private _view?: vscode.WebviewView;

	constructor() {
		console.log('üéØ PROMPTS: Provider vytvo≈ôen');
	}

	public resolveWebviewView(
		webviewView: vscode.WebviewView,
		context: vscode.WebviewViewResolveContext,
		_token: vscode.CancellationToken,
	) {
		console.log('üéØ PROMPTS: resolveWebviewView called');
		
		this._view = webviewView;
		
		webviewView.webview.options = {
			enableScripts: false,
			localResourceRoots: []
		};

		// RADIK√ÅLN√ç TEST - nejjednodu≈°≈°√≠ mo≈æn√Ω HTML
		const simpleHtml = `<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"></head>
<body style="color: white; padding: 20px; font-family: Arial;">
<h1>üöÄ FUNGUJE!</h1>
<p><strong>dobr√Ω den a nic nedƒõlje</strong></p>
<p>Extension je aktivn√≠ a webview funguje!</p>
<p>Poƒçet prompt≈Ø: ${recentPrompts.length}</p>
</body>
</html>`;

		webviewView.webview.html = simpleHtml;
		
		console.log('üéØ PROMPTS: Jednoduch√Ω HTML nastaven');
		
		if (outputChannel) {
			outputChannel.appendLine('üéØ PROMPTS: RADIK√ÅLN√ç TEST - jednoduch√Ω HTML nastaven');
			outputChannel.appendLine(`üéØ PROMPTS: Poƒçet prompt≈Ø: ${recentPrompts.length}`);
		}
	}

	public refresh(): void {
		if (this._view) {
			this.updateWebview();
		}
	}

	private updateWebview(): void {
		if (!this._view) {
			console.log('üéØ PROMPTS: Webview je≈°tƒõ nen√≠ p≈ôipraven√Ω');
			return;
		}
		
		const html = this.createPromptsHtml();
		this._view.webview.html = html;
		
		if (outputChannel) {
			outputChannel.appendLine(`üéØ PROMPTS: HTML nastaven, zobrazeno ${recentPrompts.length} prompt≈Ø`);
		}
	}

	private createPromptsHtml(): string {
		let promptsHtml = '';
		
		if (recentPrompts.length > 0) {
			// Zobraz maxim√°lnƒõ 10 posledn√≠ch prompt≈Ø
			const displayPrompts = recentPrompts.slice(0, 10);
			
			promptsHtml = displayPrompts.map((prompt, index) => {
				const shortPrompt = prompt.length > 100 ? prompt.substring(0, 100) + '...' : prompt;
				return `
<div class="prompt-item">
	<div class="prompt-number">Prompt #${index + 1}</div>
	<div class="prompt-text">${shortPrompt}</div>
</div>`;
			}).join('');
		} else {
			promptsHtml = `
<div class="no-prompts">
	<p>üîç ≈Ω√°dn√© SpecStory prompty nenalezeny</p>
	<p>Vytvo≈ôte SpecStory konverzaci pro zobrazen√≠ prompt≈Ø</p>
</div>`;
		}

		return `<!DOCTYPE html>
<html lang="cs">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>SpecStory Prompts</title>
	<style>
		body {
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
			background-color: #252526;
			color: #cccccc;
			margin: 0;
			padding: 10px;
			font-size: 13px;
		}
		.header {
			background-color: #2d2d30;
			padding: 10px;
			border-radius: 5px;
			margin-bottom: 15px;
			text-align: center;
		}
		.prompt-item {
			background-color: #1e1e1e;
			border: 1px solid #3c3c3c;
			border-left: 4px solid #007acc;
			margin: 8px 0;
			padding: 12px;
			border-radius: 3px;
		}
		.prompt-number {
			font-weight: bold;
			color: #569cd6;
			margin-bottom: 5px;
		}
		.prompt-text {
			color: #d4d4d4;
			line-height: 1.4;
		}
		.no-prompts {
			text-align: center;
			padding: 20px;
			color: #888;
		}
		.status {
			margin-top: 20px;
			padding: 10px;
			background-color: #0e639c;
			border-radius: 3px;
			text-align: center;
			color: white;
		}
	</style>
</head>
<body>

<div class="header">
	<h2 style="margin: 0; color: #4ec9b0;">üìã SpecStory AI Prompts</h2>
	<small>Celkem: ${recentPrompts.length} prompt≈Ø</small>
</div>

${promptsHtml}

<div class="status">
	‚úÖ Extension aktivn√≠<br>
	üìÅ Naƒçteno: ${recentPrompts.length} prompt≈Ø<br>
	üìÖ ${new Date().toLocaleString('cs-CZ')}
</div>

</body>
</html>`;
	}
}

export async function activate(context: vscode.ExtensionContext) {
	console.log('üöÄ AKTIVACE: Extension se spou≈°t√≠...');
	
	// Vytvo≈ô output channel pro debugging
	outputChannel = vscode.window.createOutputChannel('SpecStory Prompts');
	outputChannel.show();
	outputChannel.appendLine('üöÄ PROMPTS: Extension spou≈°tƒõn√≠...');
	
	// NEJD≈ò√çVE naƒçti prompty
	await loadExistingPrompts();
	outputChannel.appendLine(`üöÄ PROMPTS: Po naƒçten√≠ m√°me ${recentPrompts.length} prompt≈Ø`);
	
	// POTOM vytvo≈ô a registruj provider
	const promptsProvider = new PromptsProvider();
	
	outputChannel.appendLine(`üöÄ PROMPTS: Registruji provider s viewType: ${PromptsProvider.viewType}`);
	const registration = vscode.window.registerWebviewViewProvider(
		PromptsProvider.viewType,
		promptsProvider
	);
	
	outputChannel.appendLine('üöÄ PROMPTS: Provider zaregistrov√°n √∫spƒõ≈°nƒõ');
	
	// Sleduj nov√© SpecStory soubory
	const watcher = vscode.workspace.createFileSystemWatcher('**/.specstory/history/*.md');
	
	watcher.onDidCreate(uri => {
		if (isValidSpecStoryFile(uri.fsPath)) {
			outputChannel.appendLine(`üìù Nov√Ω SpecStory soubor: ${path.basename(uri.fsPath)}`);
			loadPromptsFromFile(uri.fsPath);
			// Refresh webview
			promptsProvider.refresh();
		}
	});
	
	// P≈ôidej do subscriptions pro cleanup
	context.subscriptions.push(outputChannel, registration, watcher);
	
	outputChannel.appendLine(`üöÄ PROMPTS: Aktivace dokonƒçena - celkem ${recentPrompts.length} prompt≈Ø`);
	outputChannel.appendLine('üöÄ PROMPTS: Otev≈ôi Activity Bar panel SpecStory AI!');
	
	console.log('üöÄ AKTIVACE: Extension √∫spƒõ≈°nƒõ aktivov√°n');
}

// Funkce pro naƒçten√≠ existuj√≠c√≠ch prompt≈Ø
async function loadExistingPrompts(): Promise<void> {
	try {
		outputChannel.appendLine('üîç Hled√°n√≠ existuj√≠c√≠ch SpecStory soubor≈Ø...');
		
		const files = await vscode.workspace.findFiles('**/.specstory/history/*.md');
		outputChannel.appendLine(`ÔøΩ Nalezeno ${files.length} SpecStory soubor≈Ø`);
		
		if (files.length > 0) {
			// Sort files by timestamp (newest first)
			const sortedFiles = files.sort((a, b) => {
				const nameA = path.basename(a.fsPath);
				const nameB = path.basename(b.fsPath);
				return nameB.localeCompare(nameA); // Simple name comparison for now
			});
			
			// Process files to extract prompts
			sortedFiles.forEach(file => {
				if (isValidSpecStoryFile(file.fsPath)) {
					loadPromptsFromFile(file.fsPath);
				}
			});
			
			outputChannel.appendLine(`‚úÖ Celkem naƒçteno ${recentPrompts.length} prompt≈Ø z ${sortedFiles.length} soubor≈Ø`);
		} else {
			outputChannel.appendLine('‚ÑπÔ∏è ≈Ω√°dn√© SpecStory soubory nenalezeny');
			// P≈ôid√°me test prompty pokud nejsou ≈æ√°dn√© re√°ln√©
			recentPrompts.push('dobr√Ω den a nic nedƒõlje');
			recentPrompts.push('TEST: Dummy prompt pro testov√°n√≠');
			outputChannel.appendLine('üéØ P≈ôid√°ny test prompty pro demonstraci');
		}
	} catch (error) {
		outputChannel.appendLine(`‚ùå Chyba p≈ôi naƒç√≠t√°n√≠ prompt≈Ø: ${error}`);
	}
}

export function deactivate() {
	console.log('üöÄ DEAKTIVACE: Extension se vyp√≠n√°');
	if (outputChannel) {
		outputChannel.appendLine('üöÄ DUMMY: Extension deactivated');
	}
}
