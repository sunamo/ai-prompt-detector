import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';

let outputChannel: vscode.OutputChannel;
let recentPrompts: string[] = [];

// Funkce pro validaci SpecStory souborÅ¯
function isValidSpecStoryFile(filePath: string): boolean {
	try {
		const fileName = path.basename(filePath);
		// Check if filename matches SpecStory pattern: YYYY-MM-DD_HH-mmZ-*.md
		const specStoryPattern = /^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}Z-.+\.md$/;
		if (!specStoryPattern.test(fileName)) {
			return false;
		}
		
		// Check if file exists and contains SpecStory markers
		if (!fs.existsSync(filePath)) {
			return false;
		}
		
		const content = fs.readFileSync(filePath, 'utf8');
		return content.includes('<!-- Generated by SpecStory -->') || 
		       content.includes('_**User**_') || 
		       content.includes('_**Assistant**_');
	} catch (error) {
		return false;
	}
}

// Funkce pro extrakci promptÅ¯ ze SpecStory obsahu
function extractPromptsFromContent(content: string): string[] {
	const prompts: string[] = [];
	
	try {
		// Split content by user/assistant markers
		const sections = content.split(/(?=_\*\*User\*\*_|_\*\*Assistant\*\*_)/);
		
		for (let i = 0; i < sections.length; i++) {
			const section = sections[i];
			// Look for user sections
			if (section.includes('_**User**_')) {
				// Extract text after the user marker
				const lines = section.split('\n');
				const userPrompt: string[] = [];
				let foundUserMarker = false;
				
				for (const line of lines) {
					if (line.includes('_**User**_')) {
						foundUserMarker = true;
						continue;
					}
					
					if (foundUserMarker) {
						// Stop at separator or assistant marker
						if (line.includes('---') || line.includes('_**Assistant**_')) {
							break;
						}
						
						// Add non-empty lines to prompt
						const trimmedLine = line.trim();
						if (trimmedLine) {
							userPrompt.push(trimmedLine);
						}
					}
				}
				
				// Join the prompt lines and add if not empty
				if (userPrompt.length > 0) {
					const fullPrompt = userPrompt.join(' ').trim();
					if (fullPrompt.length > 0) {
						prompts.push(fullPrompt);
					}
				}
			}
		}
		
		// Reverse prompts so newest prompts in file come first
		return prompts.reverse();
		
	} catch (error) {
		console.error('Error extracting prompts:', error);
	}
	
	return prompts;
}

// Funkce pro naÄtenÃ­ promptÅ¯ ze souboru
function loadPromptsFromFile(filePath: string): void {
	try {
		const content = fs.readFileSync(filePath, 'utf8');
		const extractedPrompts = extractPromptsFromContent(content);
		
		// Add all prompts from this file
		extractedPrompts.forEach(prompt => {
			recentPrompts.push(prompt);
		});
		
		if (outputChannel) {
			outputChannel.appendLine(`ğŸ“ Loaded ${extractedPrompts.length} prompts from ${path.basename(filePath)}`);
		}
	} catch (error) {
		console.error('Error loading prompts from file:', error);
	}
}

// ACTIVITY BAR PROVIDER S REÃLNÃMI PROMPTY
class PromptsProvider implements vscode.WebviewViewProvider {
	public static readonly viewType = 'specstory-autosave-view';
	private _view?: vscode.WebviewView;

	constructor() {
		console.log('ğŸ¯ PROMPTS: Provider vytvoÅ™en');
	}

	public resolveWebviewView(
		webviewView: vscode.WebviewView,
		context: vscode.WebviewViewResolveContext,
		_token: vscode.CancellationToken,
	) {
		console.log('ğŸ¯ PROMPTS: resolveWebviewView called');
		
		this._view = webviewView;
		
		webviewView.webview.options = {
			enableScripts: false,
			localResourceRoots: []
		};

		// OKAMÅ½ITÄš nastav HTML
		this.updateWebview();
		
		if (outputChannel) {
			outputChannel.appendLine('ğŸ¯ PROMPTS: Webview nastaven s reÃ¡lnÃ½mi prompty');
			outputChannel.appendLine(`ğŸ¯ PROMPTS: PoÄet promptÅ¯ k zobrazenÃ­: ${recentPrompts.length}`);
		}
	}

	public refresh(): void {
		if (this._view) {
			this.updateWebview();
		}
	}

	private updateWebview(): void {
		if (!this._view) {
			console.log('ğŸ¯ PROMPTS: Webview jeÅ¡tÄ› nenÃ­ pÅ™ipravenÃ½');
			return;
		}
		
		const html = this.createPromptsHtml();
		this._view.webview.html = html;
		
		if (outputChannel) {
			outputChannel.appendLine(`ğŸ¯ PROMPTS: HTML nastaven, zobrazeno ${recentPrompts.length} promptÅ¯`);
		}
	}

	private createPromptsHtml(): string {
		let promptsHtml = '';
		
		if (recentPrompts.length > 0) {
			// Zobraz maximÃ¡lnÄ› 10 poslednÃ­ch promptÅ¯
			const displayPrompts = recentPrompts.slice(0, 10);
			
			promptsHtml = displayPrompts.map((prompt, index) => {
				const shortPrompt = prompt.length > 100 ? prompt.substring(0, 100) + '...' : prompt;
				return `
<div class="prompt-item">
	<div class="prompt-number">Prompt #${index + 1}</div>
	<div class="prompt-text">${shortPrompt}</div>
</div>`;
			}).join('');
		} else {
			promptsHtml = `
<div class="no-prompts">
	<p>ğŸ” Å½Ã¡dnÃ© SpecStory prompty nenalezeny</p>
	<p>VytvoÅ™te SpecStory konverzaci pro zobrazenÃ­ promptÅ¯</p>
</div>`;
		}

		return `<!DOCTYPE html>
<html lang="cs">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>SpecStory Prompts</title>
	<style>
		body {
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
			background-color: #252526;
			color: #cccccc;
			margin: 0;
			padding: 10px;
			font-size: 13px;
		}
		.header {
			background-color: #2d2d30;
			padding: 10px;
			border-radius: 5px;
			margin-bottom: 15px;
			text-align: center;
		}
		.prompt-item {
			background-color: #1e1e1e;
			border: 1px solid #3c3c3c;
			border-left: 4px solid #007acc;
			margin: 8px 0;
			padding: 12px;
			border-radius: 3px;
		}
		.prompt-number {
			font-weight: bold;
			color: #569cd6;
			margin-bottom: 5px;
		}
		.prompt-text {
			color: #d4d4d4;
			line-height: 1.4;
		}
		.no-prompts {
			text-align: center;
			padding: 20px;
			color: #888;
		}
		.status {
			margin-top: 20px;
			padding: 10px;
			background-color: #0e639c;
			border-radius: 3px;
			text-align: center;
			color: white;
		}
	</style>
</head>
<body>

<div class="header">
	<h2 style="margin: 0; color: #4ec9b0;">ğŸ“‹ SpecStory AI Prompts</h2>
	<small>Celkem: ${recentPrompts.length} promptÅ¯</small>
</div>

${promptsHtml}

<div class="status">
	âœ… Extension aktivnÃ­<br>
	ğŸ“ NaÄteno: ${recentPrompts.length} promptÅ¯<br>
	ğŸ“… ${new Date().toLocaleString('cs-CZ')}
</div>

</body>
</html>`;
	}
}

export async function activate(context: vscode.ExtensionContext) {
	console.log('ğŸš€ AKTIVACE: Extension se spouÅ¡tÃ­...');
	
	// VytvoÅ™ output channel pro debugging
	outputChannel = vscode.window.createOutputChannel('SpecStory Prompts');
	outputChannel.show();
	outputChannel.appendLine('ğŸš€ PROMPTS: Extension spouÅ¡tÄ›nÃ­...');
	
	// NEJDÅ˜ÃVE naÄti prompty
	await loadExistingPrompts();
	outputChannel.appendLine(`ğŸš€ PROMPTS: Po naÄtenÃ­ mÃ¡me ${recentPrompts.length} promptÅ¯`);
	
	// POTOM vytvoÅ™ a registruj provider
	const promptsProvider = new PromptsProvider();
	
	outputChannel.appendLine(`ğŸš€ PROMPTS: Registruji provider s viewType: ${PromptsProvider.viewType}`);
	const registration = vscode.window.registerWebviewViewProvider(
		PromptsProvider.viewType,
		promptsProvider
	);
	
	outputChannel.appendLine('ğŸš€ PROMPTS: Provider zaregistrovÃ¡n ÃºspÄ›Å¡nÄ›');
	
	// Sleduj novÃ© SpecStory soubory
	const watcher = vscode.workspace.createFileSystemWatcher('**/.specstory/history/*.md');
	
	watcher.onDidCreate(uri => {
		if (isValidSpecStoryFile(uri.fsPath)) {
			outputChannel.appendLine(`ğŸ“ NovÃ½ SpecStory soubor: ${path.basename(uri.fsPath)}`);
			loadPromptsFromFile(uri.fsPath);
			// Refresh webview
			promptsProvider.refresh();
		}
	});
	
	// PÅ™idej do subscriptions pro cleanup
	context.subscriptions.push(outputChannel, registration, watcher);
	
	outputChannel.appendLine(`ğŸš€ PROMPTS: Aktivace dokonÄena - celkem ${recentPrompts.length} promptÅ¯`);
	outputChannel.appendLine('ğŸš€ PROMPTS: OtevÅ™i Activity Bar panel SpecStory AI!');
	
	console.log('ğŸš€ AKTIVACE: Extension ÃºspÄ›Å¡nÄ› aktivovÃ¡n');
}

// Funkce pro naÄtenÃ­ existujÃ­cÃ­ch promptÅ¯
async function loadExistingPrompts(): Promise<void> {
	try {
		outputChannel.appendLine('ğŸ” HledÃ¡nÃ­ existujÃ­cÃ­ch SpecStory souborÅ¯...');
		
		const files = await vscode.workspace.findFiles('**/.specstory/history/*.md');
		outputChannel.appendLine(`ï¿½ Nalezeno ${files.length} SpecStory souborÅ¯`);
		
		if (files.length > 0) {
			// Sort files by timestamp (newest first)
			const sortedFiles = files.sort((a, b) => {
				const nameA = path.basename(a.fsPath);
				const nameB = path.basename(b.fsPath);
				return nameB.localeCompare(nameA); // Simple name comparison for now
			});
			
			// Process files to extract prompts
			sortedFiles.forEach(file => {
				if (isValidSpecStoryFile(file.fsPath)) {
					loadPromptsFromFile(file.fsPath);
				}
			});
			
			outputChannel.appendLine(`âœ… Celkem naÄteno ${recentPrompts.length} promptÅ¯ z ${sortedFiles.length} souborÅ¯`);
		} else {
			outputChannel.appendLine('â„¹ï¸ Å½Ã¡dnÃ© SpecStory soubory nenalezeny');
			// PÅ™idÃ¡me test prompty pokud nejsou Å¾Ã¡dnÃ© reÃ¡lnÃ©
			recentPrompts.push('dobrÃ½ den a nic nedÄ›lje');
			recentPrompts.push('TEST: Dummy prompt pro testovÃ¡nÃ­');
			outputChannel.appendLine('ğŸ¯ PÅ™idÃ¡ny test prompty pro demonstraci');
		}
	} catch (error) {
		outputChannel.appendLine(`âŒ Chyba pÅ™i naÄÃ­tÃ¡nÃ­ promptÅ¯: ${error}`);
	}
}

export function deactivate() {
	console.log('ğŸš€ DEAKTIVACE: Extension se vypÃ­nÃ¡');
	if (outputChannel) {
		outputChannel.appendLine('ğŸš€ DUMMY: Extension deactivated');
	}
}
