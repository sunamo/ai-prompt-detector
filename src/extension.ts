import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';

let outputChannel: vscode.OutputChannel;
let recentPrompts: string[] = []; // SpecStory exported prompts from .md files
let aiPromptCounter: number = 0; // Counter for AI prompts to GitHub Copilot
let statusBarItem: vscode.StatusBarItem; // VS Code status bar item

// Auto-save configuration (hardcoded to true)
const AUTO_SAVE_ENABLED = true;
const AUTO_SAVE_INTERVAL = 5000; // 5 seconds
const AUTO_SAVE_PATTERNS = ['**/*.md', '**/*.txt', '**/*.json'];
let autoSaveTimer: NodeJS.Timeout | undefined;

// Funkce pro validaci SpecStory soubor≈Ø
function isValidSpecStoryFile(filePath: string): boolean {
	try {
		const fileName = path.basename(filePath);
		// Check if filename matches SpecStory pattern: YYYY-MM-DD_HH-mmZ-*.md
		const specStoryPattern = /^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}Z-.+\.md$/;
		if (!specStoryPattern.test(fileName)) {
			return false;
		}
		
		// Check if file exists and contains SpecStory markers
		if (!fs.existsSync(filePath)) {
			return false;
		}
		
		const content = fs.readFileSync(filePath, 'utf8');
		return content.includes('<!-- Generated by SpecStory -->') || 
		       content.includes('_**User**_') || 
		       content.includes('_**Assistant**_');
	} catch (error) {
		return false;
	}
}

// Funkce pro extrakci prompt≈Ø ze SpecStory obsahu
function extractPromptsFromContent(content: string): string[] {
	const prompts: string[] = [];
	
	try {
		// Split content by user/assistant markers
		const sections = content.split(/(?=_\*\*User\*\*_|_\*\*Assistant\*\*_)/);
		
		for (let i = 0; i < sections.length; i++) {
			const section = sections[i];
			// Look for user sections
			if (section.includes('_**User**_')) {
				// Extract text after the user marker
				const lines = section.split('\n');
				const userPrompt: string[] = [];
				let foundUserMarker = false;
				
				for (const line of lines) {
					if (line.includes('_**User**_')) {
						foundUserMarker = true;
						continue;
					}
					
					if (foundUserMarker) {
						// Stop at separator or assistant marker
						if (line.includes('---') || line.includes('_**Assistant**_')) {
							break;
						}
						
						// Add non-empty lines to prompt
						const trimmedLine = line.trim();
						if (trimmedLine) {
							userPrompt.push(trimmedLine);
						}
					}
				}
				
				// Join the prompt lines and add if not empty
				if (userPrompt.length > 0) {
					const fullPrompt = userPrompt.join(' ').trim();
					if (fullPrompt.length > 0) {
						prompts.push(fullPrompt);
					}
				}
			}
		}
		
		// Reverse prompts so newest prompts in file come first
		return prompts.reverse();
		
	} catch (error) {
		console.error('Error extracting prompts:', error);
	}
	
	return prompts;
}

// Funkce pro naƒçten√≠ prompt≈Ø ze souboru
function loadPromptsFromFile(filePath: string): void {
	try {
		const content = fs.readFileSync(filePath, 'utf8');
		const extractedPrompts = extractPromptsFromContent(content);
		
		// Add all prompts from this file
		extractedPrompts.forEach(prompt => {
			recentPrompts.push(prompt);
		});
		
		if (outputChannel) {
			outputChannel.appendLine(`üìÅ Loaded ${extractedPrompts.length} prompts from ${path.basename(filePath)}`);
		}
	} catch (error) {
		console.error('Error loading prompts from file:', error);
	}
}

// ACTIVITY BAR PROVIDER S RE√ÅLN√ùMI PROMPTY
class PromptsProvider implements vscode.WebviewViewProvider {
	public static readonly viewType = 'specstory-autosave-view';
	private _view?: vscode.WebviewView;

	constructor() {
		console.log('üéØ PROMPTS: Provider vytvo≈ôen');
	}

	public resolveWebviewView(
		webviewView: vscode.WebviewView,
		context: vscode.WebviewViewResolveContext,
		_token: vscode.CancellationToken,
	) {
		console.log('üéØ PROMPTS: resolveWebviewView called');
		
		this._view = webviewView;
		
		webviewView.webview.options = {
			enableScripts: false,
			localResourceRoots: []
		};

		// ZOBRAZ RE√ÅLN√â PROMPTY Z .MD SOUBOR≈Æ
		this.updateWebview();
		
		console.log('üéØ PROMPTS: Re√°ln√© prompty nastaveny');
		
		if (outputChannel) {
			outputChannel.appendLine('üéØ PROMPTS: Zobrazuji re√°ln√© prompty z SpecStory soubor≈Ø');
			outputChannel.appendLine(`üéØ PROMPTS: Poƒçet prompt≈Ø k zobrazen√≠: ${recentPrompts.length}`);
		}
	}

	public refresh(): void {
		if (this._view) {
			this.updateWebview();
		}
	}

	private updateWebview(): void {
		if (!this._view) {
			console.log('üéØ PROMPTS: Webview je≈°tƒõ nen√≠ p≈ôipraven√Ω');
			return;
		}
		
		const html = this.createPromptsHtml();
		this._view.webview.html = html;
		
		if (outputChannel) {
			outputChannel.appendLine(`üéØ PROMPTS: HTML nastaven, zobrazeno ${recentPrompts.length} prompt≈Ø`);
		}
	}

	private createPromptsHtml(): string {
		let promptsHtml = '';
		
		// Get max prompts from settings
		const config = vscode.workspace.getConfiguration('specstory-autosave');
		const maxPrompts = config.get<number>('maxPrompts', 50);
		
		if (recentPrompts.length > 0) {
			// Zobraz maxim√°lnƒõ podle nastaven√≠
			const displayPrompts = recentPrompts.slice(0, maxPrompts);
			
			promptsHtml = displayPrompts.map((prompt, index) => {
				// Zkra≈• prompt na rozumnou d√©lku pro zobrazen√≠
				const shortPrompt = prompt.length > 150 ? prompt.substring(0, 150) + '...' : prompt;
				
				// Escapuj HTML znaky pro bezpeƒçnost
				const safePrompt = shortPrompt
					.replace(/&/g, '&amp;')
					.replace(/</g, '&lt;')
					.replace(/>/g, '&gt;')
					.replace(/"/g, '&quot;');
				
				return `
<div class="prompt-item">
	<div class="prompt-number">#${index + 1}</div>
	<div class="prompt-text">${safePrompt}</div>
</div>`;
			}).join('');
		} else {
			promptsHtml = `
<div class="no-prompts">
	<p>üîç ≈Ω√°dn√© SpecStory prompty nenalezeny</p>
	<p>Vytvo≈ôte SpecStory konverzaci pro zobrazen√≠ prompt≈Ø</p>
</div>`;
		}

	// Get extension version from package.json
	const extensionVersion = vscode.extensions.getExtension('sunamocz.specstory-autosave')?.packageJSON.version || '1.1.72';

	return `<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>SpecStory Prompts</title>
	<style>
		body {
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
			background-color: #1e1e1e;
			color: #cccccc;
			margin: 0;
			padding: 8px;
			font-size: 12px;
			line-height: 1.4;
		}
		.prompt-item {
			background-color: #252526;
			border: 1px solid #3c3c3c;
			border-left: 4px solid #007acc;
			margin: 6px 0;
			padding: 8px;
			border-radius: 3px;
			transition: background-color 0.2s;
		}
		.prompt-item:hover {
			background-color: #2d2d30;
		}
		.prompt-number {
			font-weight: bold;
			color: #569cd6;
			margin-bottom: 4px;
			font-size: 11px;
		}
		.prompt-text {
			color: #d4d4d4;
			font-size: 11px;
			line-height: 1.3;
			word-wrap: break-word;
		}
		.no-prompts {
			text-align: center;
			padding: 20px;
			color: #888;
		}
		.header-bar {
			margin-bottom: 15px;
			padding: 8px;
			background-color: #0e639c;
			border-radius: 3px;
			text-align: center;
			color: white;
			font-size: 10px;
		}
	</style>
</head>
<body>

<div class="header-bar">
	üìä Total: ${recentPrompts.length} prompts (max ${maxPrompts}) | ‚öôÔ∏è Change max count in settings
</div>

${promptsHtml}

</body>
</html>`;
	}
}

export async function activate(context: vscode.ExtensionContext) {
	console.log('üöÄ AKTIVACE: Extension se spou≈°t√≠...');
	
	// Vytvo≈ô output channel pro debugging
	outputChannel = vscode.window.createOutputChannel('SpecStory Prompts');
	outputChannel.show();
	outputChannel.appendLine('üöÄ PROMPTS: Extension spou≈°tƒõn√≠...');
	
	// Create status bar item
	statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
	statusBarItem.show();
	
	// Update status bar with initial values
	const updateStatusBar = () => {
		const extensionVersion = vscode.extensions.getExtension('sunamocz.specstory-autosave')?.packageJSON.version || '1.1.73';
		statusBarItem.text = `ü§ñ AI Prompts: ${aiPromptCounter} | v${extensionVersion}`;
		statusBarItem.tooltip = 'SpecStory AutoSave + AI Copilot Prompt Detection';
	};
	updateStatusBar();
	
	// NEJD≈ò√çVE naƒçti prompty
	await loadExistingPrompts();
	outputChannel.appendLine(`üöÄ PROMPTS: Po naƒçten√≠ m√°me ${recentPrompts.length} prompt≈Ø`);
	
	// POTOM vytvo≈ô a registruj provider
	const promptsProvider = new PromptsProvider();
	
	outputChannel.appendLine(`üöÄ PROMPTS: Registruji provider s viewType: ${PromptsProvider.viewType}`);
	const registration = vscode.window.registerWebviewViewProvider(
		PromptsProvider.viewType,
		promptsProvider
	);
	
	outputChannel.appendLine('üöÄ PROMPTS: Provider zaregistrov√°n √∫spƒõ≈°nƒõ');
	
	// Sleduj nov√© SpecStory soubory
	const watcher = vscode.workspace.createFileSystemWatcher('**/.specstory/history/*.md');
	
	watcher.onDidCreate(uri => {
		if (isValidSpecStoryFile(uri.fsPath)) {
			outputChannel.appendLine(`üìù Nov√Ω SpecStory soubor: ${path.basename(uri.fsPath)}`);
			loadPromptsFromFile(uri.fsPath);
			// Refresh webview
			promptsProvider.refresh();
		}
	});

	// Listen for configuration changes
	const configWatcher = vscode.workspace.onDidChangeConfiguration(e => {
		if (e.affectsConfiguration('specstory-autosave.maxPrompts')) {
			const config = vscode.workspace.getConfiguration('specstory-autosave');
			const maxPrompts = config.get<number>('maxPrompts', 50);
			outputChannel.appendLine(`‚öôÔ∏è Settings changed: maxPrompts = ${maxPrompts}`);
			// Refresh webview to show new limit
			promptsProvider.refresh();
		}
	});

	// Monitor AI prompt counter - detect Copilot activity
	const disposable = vscode.commands.registerCommand('type', (args) => {
		// Increment counter when user types in Copilot or sends prompts
		if (args && typeof args.text === 'string') {
			// Simple detection - increment on Enter key or specific patterns
			if (args.text.includes('\n') || args.text.includes('\r')) {
				aiPromptCounter++;
				outputChannel.appendLine(`ü§ñ AI Prompt detected! Counter: ${aiPromptCounter}`);
				// Update status bar
				updateStatusBar();
				// Refresh webview to show new counter
				promptsProvider.refresh();
			}
		}
		return vscode.commands.executeCommand('default:type', args);
	});

	// Auto-save functionality (hardcoded enabled)
	if (AUTO_SAVE_ENABLED) {
		outputChannel.appendLine(`üíæ AUTO-SAVE: Enabled with interval ${AUTO_SAVE_INTERVAL}ms`);
		outputChannel.appendLine(`üíæ AUTO-SAVE: Patterns: ${AUTO_SAVE_PATTERNS.join(', ')}`);
		
		const startAutoSave = () => {
			if (autoSaveTimer) {
				clearInterval(autoSaveTimer);
			}
			
			autoSaveTimer = setInterval(async () => {
				try {
					// Save all dirty editors that match our patterns
					const dirtyEditors = vscode.window.visibleTextEditors.filter(editor => 
						editor.document.isDirty && 
						AUTO_SAVE_PATTERNS.some(pattern => 
							editor.document.fileName.includes('.md') || 
							editor.document.fileName.includes('.txt') || 
							editor.document.fileName.includes('.json')
						)
					);
					
					if (dirtyEditors.length > 0) {
						outputChannel.appendLine(`üíæ AUTO-SAVE: Saving ${dirtyEditors.length} dirty files`);
						
						for (const editor of dirtyEditors) {
							await editor.document.save();
							outputChannel.appendLine(`üíæ AUTO-SAVE: Saved ${path.basename(editor.document.fileName)}`);
						}
					}
				} catch (error) {
					outputChannel.appendLine(`‚ùå AUTO-SAVE: Error saving files: ${error}`);
				}
			}, AUTO_SAVE_INTERVAL);
		};
		
		startAutoSave();
	}
	
	// P≈ôidej do subscriptions pro cleanup
	context.subscriptions.push(outputChannel, registration, watcher, configWatcher, disposable, statusBarItem);
	
	// Cleanup auto-save timer on deactivation
	context.subscriptions.push({
		dispose: () => {
			if (autoSaveTimer) {
				clearInterval(autoSaveTimer);
				autoSaveTimer = undefined;
				outputChannel.appendLine('üíæ AUTO-SAVE: Timer cleared');
			}
		}
	});
	
	outputChannel.appendLine(`üöÄ PROMPTS: Aktivace dokonƒçena - celkem ${recentPrompts.length} prompt≈Ø`);
	outputChannel.appendLine('üöÄ PROMPTS: Otev≈ôi Activity Bar panel SpecStory AI!');
	
	console.log('üöÄ AKTIVACE: Extension √∫spƒõ≈°nƒõ aktivov√°n');
}

// Funkce pro naƒçten√≠ existuj√≠c√≠ch prompt≈Ø
async function loadExistingPrompts(): Promise<void> {
	try {
		outputChannel.appendLine('üîç Hled√°n√≠ existuj√≠c√≠ch SpecStory soubor≈Ø...');
		
		const files = await vscode.workspace.findFiles('**/.specstory/history/*.md');
		outputChannel.appendLine(`ÔøΩ Nalezeno ${files.length} SpecStory soubor≈Ø`);
		
		if (files.length > 0) {
			// Sort files by timestamp (newest first)
			const sortedFiles = files.sort((a, b) => {
				const nameA = path.basename(a.fsPath);
				const nameB = path.basename(b.fsPath);
				return nameB.localeCompare(nameA); // Simple name comparison for now
			});
			
			// Process files to extract prompts
			sortedFiles.forEach(file => {
				if (isValidSpecStoryFile(file.fsPath)) {
					loadPromptsFromFile(file.fsPath);
				}
			});
			
			outputChannel.appendLine(`‚úÖ Celkem naƒçteno ${recentPrompts.length} prompt≈Ø z ${sortedFiles.length} soubor≈Ø`);
		} else {
			outputChannel.appendLine('‚ÑπÔ∏è ≈Ω√°dn√© SpecStory soubory nenalezeny');
			// P≈ôid√°me test prompty pokud nejsou ≈æ√°dn√© re√°ln√©
			recentPrompts.push('dobr√Ω den a nic nedƒõlje');
			recentPrompts.push('TEST: Dummy prompt pro testov√°n√≠');
			outputChannel.appendLine('üéØ P≈ôid√°ny test prompty pro demonstraci');
		}
	} catch (error) {
		outputChannel.appendLine(`‚ùå Chyba p≈ôi naƒç√≠t√°n√≠ prompt≈Ø: ${error}`);
	}
}

export function deactivate() {
	console.log('üöÄ DEAKTIVACE: Extension se vyp√≠n√°');
	
	// Clear auto-save timer
	if (autoSaveTimer) {
		clearInterval(autoSaveTimer);
		autoSaveTimer = undefined;
	}
	
	if (outputChannel) {
		outputChannel.appendLine('üíæ AUTO-SAVE: Extension deactivated, timer cleared');
		outputChannel.appendLine('üöÄ DUMMY: Extension deactivated');
	}
}
