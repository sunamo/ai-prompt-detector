import * as fs from 'fs';
import * as path from 'path';
import { writeLog } from './logger';

/** Ovƒõ≈ôen√≠ platnosti SpecStory souboru podle n√°zvu a typick√Ωch marker≈Ø obsahu. */
export function isValidSpecStoryFile(filePath: string): boolean {
	try {
		const fileName = path.basename(filePath);
		const specStoryPattern = /^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}Z-.+\.md$/;
		if (!specStoryPattern.test(fileName)) return false;
		if (!fs.existsSync(filePath)) return false;
		const content = fs.readFileSync(filePath, 'utf8');
		return content.includes('<!-- Generated by SpecStory -->') ||
			   content.includes('_**User**_') ||
			   content.includes('_**Assistant**_');
	} catch { return false; }
}

/** Extrakce prompt≈Ø u≈æivatele z markdown obsahu konverzace. */
export function extractPromptsFromContent(content: string): string[] {
	const prompts: string[] = [];
	try {
		const sections = content.split(/(?=_\*\*User\*\*_ |_\*\*Assistant\*\*_)/);
		for (let i = 0; i < sections.length; i++) {
			const section = sections[i];
			if (section.includes('_**User**_')) {
				const lines = section.split('\n');
				const userPrompt: string[] = [];
				let foundUserMarker = false;
				for (const line of lines) {
					if (line.includes('_**User**_')) { foundUserMarker = true; continue; }
					if (foundUserMarker) {
						if (line.includes('---') || line.includes('_**Assistant**_')) break;
						const trimmedLine = line.trim();
						if (trimmedLine) userPrompt.push(trimmedLine);
					}
				}
				if (userPrompt.length > 0) { const fullPrompt = userPrompt.join(' ').trim(); if (fullPrompt.length > 0) prompts.push(fullPrompt); }
			}
		}
		return prompts.reverse();
	} catch (error) { writeLog(`Error extracting prompts: ${error}`, false); }
	return prompts;
}

/** Naƒçte soubor a p≈ôid√° do recentPrompts v≈°echny u≈æivatelsk√© prompty. */
export function loadPromptsFromFile(filePath: string, recentPrompts: string[]): void {
	try {
		const content = fs.readFileSync(filePath, 'utf8');
		const extractedPrompts = extractPromptsFromContent(content);
		extractedPrompts.forEach(prompt => { recentPrompts.push(prompt); });
		writeLog(`üìÅ Loaded ${extractedPrompts.length} prompts from ${path.basename(filePath)}`, false);
	} catch (error) { writeLog(`Error loading prompts from file: ${error}`, false); }
}
