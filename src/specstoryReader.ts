/**
 * ÄŒITELNOST: Soubor musÃ­ zÅ¯stat vÅ¾dy plnÄ› ÄitelnÃ½ pro programÃ¡tora.
 * Å½Ã¡dnÃ© umÄ›lÃ© zkracovÃ¡nÃ­ Å™Ã¡dkÅ¯, sluÄovÃ¡nÃ­ nesouvisejÃ­cÃ­ch pÅ™Ã­kazÅ¯ na jeden Å™Ã¡dek
 * ani minifikace. SnÃ­Å¾enÃ­ poÄtu Å™Ã¡dkÅ¯ bez jasnÃ©ho, zdokumentovanÃ©ho zlepÅ¡enÃ­
 * Äitelnosti je REGRESE a musÃ­ bÃ½t vrÃ¡ceno. ZachovÃ¡vej logickÃ© bloky a vertikÃ¡lnÃ­ strukturu.
 */

import * as fs from 'fs';
import * as path from 'path';

<<<<<<< HEAD
/** OvÄ›Å™enÃ­ platnosti SpecStory souboru podle nÃ¡zvu a typickÃ½ch markerÅ¯ obsahu. */
export function isValidSpecStoryFile(filePath: string): boolean {
	try {
		const fileName = path.basename(filePath);
		const specStoryPattern = /^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}Z-.+\.md$/;
		if (!specStoryPattern.test(fileName)) return false;
		if (!fs.existsSync(filePath)) return false;
		const content = fs.readFileSync(filePath, 'utf8');
		return content.includes('<!-- Generated by SpecStory -->') ||
			   content.includes('_**User**_') ||
			   content.includes('_**Assistant**_');
	} catch { return false; }
}

/** Extrakce promptÅ¯ uÅ¾ivatele z markdown obsahu konverzace. */
export function extractPromptsFromContent(content: string): string[] {
	const prompts: string[] = [];
	try {
		const sections = content.split(/(?=_\*\*User\*\*_ |_\*\*Assistant\*\*_)/);
		for (let i = 0; i < sections.length; i++) {
			const section = sections[i];
			if (section.includes('_**User**_')) {
				const lines = section.split('\n');
				const userPrompt: string[] = [];
				let foundUserMarker = false;
				for (const line of lines) {
					if (line.includes('_**User**_')) { foundUserMarker = true; continue; }
					if (foundUserMarker) {
						if (line.includes('---') || line.includes('_**Assistant**_')) break;
						const trimmedLine = line.trim();
						if (trimmedLine) userPrompt.push(trimmedLine);
					}
				}
				if (userPrompt.length > 0) { const fullPrompt = userPrompt.join(' ').trim(); if (fullPrompt.length > 0) prompts.push(fullPrompt); }
			}
		}
		return prompts.reverse();
	} catch (error) { writeLog(`Error extracting prompts: ${error}`, false); }
	return prompts;
}

/** NaÄte soubor a pÅ™idÃ¡ do recentPrompts vÅ¡echny uÅ¾ivatelskÃ© prompty. */
export function loadPromptsFromFile(filePath: string, recentPrompts: string[]): void {
	try {
		const content = fs.readFileSync(filePath, 'utf8');
		const extractedPrompts = extractPromptsFromContent(content);
		extractedPrompts.forEach(prompt => { recentPrompts.push(prompt); });
		writeLog(`ğŸ“ Loaded ${extractedPrompts.length} prompts from ${path.basename(filePath)}`, false);
	} catch (error) { writeLog(`Error loading prompts from file: ${error}`, false); }
=======
/**
 * OvÄ›Å™Ã­ zda soubor odpovÃ­dÃ¡ oÄekÃ¡vanÃ©mu formÃ¡tu nÃ¡zvu SpecStory exportu.
 * @param filePath AbsolutnÃ­ cesta k souboru.
 * @returns true pokud nÃ¡zev i existence souboru vyhovujÃ­.
 */
export function isValidSpecStoryFile(filePath: string): boolean {
  const fileName = path.basename(filePath);
  return (
    /^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}Z-.+\.md$/.test(fileName) &&
    fs.existsSync(filePath)
  );
}

/**
 * NaÄte prompty z jednoho souboru SpecStory â€“ poÅ™adÃ­ v souboru se pÅ™evracÃ­ (collected.reverse())
 * aby nejnovÄ›jÅ¡Ã­ prompty danÃ©ho souboru byly dÅ™Ã­ve a zachovala se globÃ¡lnÃ­ invariantnÃ­ logika.
 * Invariant (NEPORUÅ IT): PoÅ™adÃ­ se pÅ™ipravuje takto:
 * 1. NasbÃ­rÃ¡me prompty v poÅ™adÃ­ vÃ½skytu v souboru (nejstarÅ¡Ã­ -> nejnovÄ›jÅ¡Ã­)
 * 2. PotÃ© provedeme collected.reverse() aby nejNOVÄšJÅ Ã (poslednÃ­) byl jako prvnÃ­
 * 3. VÃ½sledek pushujeme do global recent pole v tomto jiÅ¾ otoÄenÃ©m poÅ™adÃ­
 * UI (activityBarProvider) NESMÃ pÅ™idÃ¡vat reverse â€“ spoleh na zdejÅ¡Ã­ Ãºpravu.
 * JakÃ¡koliv zmÄ›na (napÅ™. zruÅ¡enÃ­ reverse a nÃ¡hrada obracenÃ­m v UI) je REGRESE.
 * @param filePath Cesta k markdown souboru.
 * @param recent Pole do nÄ›hoÅ¾ se pÅ™idÃ¡vajÃ­ nalezenÃ© prompty.
 */
export function loadPromptsFromFile(filePath: string, recent: string[]): void {
  try {
    const c = fs.readFileSync(filePath, 'utf8');
    const sections = c.split(/(?=_\*\*User\*\*_)/);
    const collected: string[] = [];
    for (const s of sections) {
      if (s.includes('_**User**_')) {
        const body = s
          .split('\n')
          .slice(1)
          .join(' ')
          .split('---')[0]
          .trim();
        if (body && body.length > 0) collected.push(body);
      }
    }
    // NEODSTRAÅ‡OVAT: ObrÃ¡cenÃ© poÅ™adÃ­ v rÃ¡mci souboru â€“ nejnovÄ›jÅ¡Ã­ (poslednÃ­ v souboru) jde prvnÃ­.
    for (const p of collected.reverse()) recent.push(p);
  } catch {}
>>>>>>> refs/remotes/origin/master
}
