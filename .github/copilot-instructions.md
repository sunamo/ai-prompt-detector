````````````instructions
```````````instructions
``````````instructions
`````````instructions
````````instructions
```````instructions
``````instructions
# AI Assistant Instructions - AI Copilot Prompt Detector Extension

## ‚úÖ Formatting Policy (Human Readable Output)
- ALL code and text the AI produces must already be cleanly formatted and human readable when shown (never rely on later formatting steps).
- Follow a Prettier‚Äëlike style (consistent indentation, spacing, trailing commas where typical, wrapped long lines sensibly).
- No minified or compressed one‚Äëline blocks unless it is a deliberate tiny snippet example.
- When editing existing files, preserve surrounding style and improve readability if previous formatting was degraded.
- Large inline arrays or objects must be split across multiple lines.
- Avoid excessively long lines (>140 chars) where reasonable.
- Always keep the final code below per‚Äëfile length limits already defined in these instructions.
- This policy is mandatory for every response containing code or documentation.

Write to me at the beginning of each prompt that you see the logs in the folder¬®

Never do something, then run install.ps1, then do something again, then run install.ps1 again. Think carefully and do only one thing.

## ‚ö†Ô∏è CRITICAL RULES - STRICTLY FOLLOW!

As a copilot, you never change versions. The version changes fundamentally only install.ps1

### üñ•Ô∏è VS CODE UI TERMINOLOGY - CRITICAL!
- **STATUS BAR** = Bottom bar in VS Code (shows branch, errors, etc.) - use `vscode.window.createStatusBarItem()`
- **HEADER BAR** = Top bar in Activity Panel webview (custom HTML div) - use `<div class="header-bar">` in webview HTML
- **Activity Bar** = Left sidebar with icons (Explorer, Search, etc.)
- **Activity Panel** = Content area when Activity Bar icon is clicked (shows our webview)

### üåç LANGUAGE POLICY - CRITICAL RULE!
- **Communication with the copilot and comments in the code are in Czech. Everything else is in English. Without exceptions.**
- **ONLY cs.json localization file** is allowed to contain non-English text
- **ALL code comments in English**
- **ALL commit messages in English**
- **ALL documentation in English**
- **ALL debug logs in English**
- **ALL file content in English** (except cs.json)

### üîß FILE REPAIR POLICY - CRITICAL RULE!
- **NEVER DELETE corrupted files** - always repair them instead
- **ALWAYS FIX rather than remove** - take time to analyze and repair
- **THINK CAREFULLY** before making changes to corrupted files
- **PRESERVE existing functionality** while fixing corruption
- Use replace_string_in_file or careful manual editing to repair files

### üìÅ FILE NAMES - CRITICAL RULE!
- **ALL instruction files must have format: `*.instructions.md`**
- **NEVER use names like `ai-instructions.md`**
- **CORRECT**: `copilot-instructions.md`, `development.instructions.md`, `deployment.instructions.md`
- **WRONG**: `ai-instructions.md`, `dev-instructions.md`, `instructions.md`
- Always check that you have correct ending `.instructions.md`

### üöÄ RELEASE at the end of every prompt
- **At the end of EVERY prompt run `.\install.ps1`**
- This script performs: build ‚Üí commit ‚Üí push ‚Üí package ‚Üí install
- Automatically creates new version and installs it
- User always has the latest version of the extension

### üìä VERSION MANAGEMENT - CRITICAL RULE!
- **ALWAYS increment only PATCH version** (e.g. 1.1.2 ‚Üí 1.1.3)
- **NEVER increment MINOR** (1.1.x ‚Üí 1.2.0) without explicit command
- **Increment MINOR version ONLY when user says "compile for marketplace"**
- **NEVER change MAJOR version** without explicit command
- Format: MAJOR.MINOR.PATCH (e.g. 1.1.15, 1.1.16, 1.1.17...)

## üéØ TARGET FUNCTIONALITY - SPECSTORY INTEGRATION

### üåç LOCALIZATION - CRITICAL RULE!
- **ALL user texts use from i18n/en.json**
- **NEVER write texts directly in code** - always through i18n system
- **CHANGELOG.md, README.md and all documents only in English**
- **Commit messages in English**
- **Code comments in English**
- **Debug logs in English**
- Use: `i18n.t('key')` instead of hardcoded texts

### üìã What the extension should do:
1. **DOES NOT READ or GENERATE SpecStory files** - SpecStory does that itself
2. **READS existing SpecStory exports** from `.specstory/history/` folders
3. **ANALYZES content** of recent conversations for context
4. **GENERATES smart notification messages** based on content analysis
5. **USES default message** if user hasn't set custom one in settings

### üìÅ SpecStory format (for reading and analysis only):
- **Location**: `[project]/.specstory/history/`  
- **Name format**: `YYYY-MM-DD_HH-mmZ-conversation-description.md`
- **Content structure**:
  ```markdown
  <!-- Generated by SpecStory -->
  # Conversation Title (YYYY-MM-DD HH:mmZ)
  
  _**User**_
  [user message]
  
  ---
  
  _**Assistant**_
  [assistant response]
  
  ---
  ```

### ü§ñ Smart notifications - logic:
- **If user HAS custom message** ‚Üí use their message
- **If user DOESN'T HAVE custom message** ‚Üí generate based on:
  - Analysis of latest SpecStory export
  - Type of conversation (coding, debugging, design, etc.)  
  - Project context (language, framework, etc.)
  - Specific problems mentioned in conversation

### üìç Examples of smart messages:
- **Debugging**: "AI just debugged! Check: ‚Ä¢ Fixed actual root cause? ‚Ä¢ Introduced new bugs? ‚Ä¢ Test edge cases"
- **HTML/CSS**: "AI worked with UI! Check: ‚Ä¢ Responsive design ‚Ä¢ Accessibility ‚Ä¢ Cross-browser compatibility"  
- **Database**: "AI modified database! Check: ‚Ä¢ Data integrity ‚Ä¢ Performance impact ‚Ä¢ Backup strategy"
- **API**: "AI created API! Check: ‚Ä¢ Error handling ‚Ä¢ Security ‚Ä¢ API documentation"

### üìù Git commit workflow
- Order: 1) Code change ‚Üí 2) Increment PATCH ‚Üí 3) `.\install.ps1` (automatically: commit ‚Üí push ‚Üí package)
- Format: `git commit -m "v1.1.3"` (always just patch++)
- Everything is done automatically through install.ps1

## ‚ö†Ô∏è CRITICAL RULES - STRICTLY FOLLOW!

### üö´ NEVER create placeholder files!
- **FORBIDDEN:** `extension_backup.ts`, `extension_clean.ts`, `extension_old.ts` etc.
- Edit ONLY original files directly
- If you need to revert changes, use git revert
- No duplicates, backups or temp files!

### üî® BUILD at the end of every prompt
- **NEVER run `pnpm run compile` separately!**
- **WORKFLOW**: Increment version ‚Üí run `.\install.ps1`
- If build fails in install.ps1:
  1. Decrease version back
  2. Fix errors
  3. Increment version again
  4. Run `.\install.ps1` again
- install.ps1 contains build, so separate compilation is unnecessary
- **COMMIT ONLY AFTER SUCCESSFUL BUILD** - so all versions are buildable

### üöÄ RELEASE at the end of every prompt
- **At the end of EVERY prompt run `.\install.ps1`**
- This script performs: build ‚Üí commit ‚Üí push ‚Üí package ‚Üí install
- Automatically creates new version and installs it
- User always has the latest version of the extension

### üìù Git commit workflow
- Order: 1) Code change ‚Üí 2) Build test ‚Üí 3) `.\install.ps1` (automatically: commit ‚Üí push ‚Üí package)
- Format: `git commit -m "v1.1.1"`
- Everything is done automatically through install.ps1

## Command Execution Policy

**‚ö†Ô∏è IMPORTANT: Run ALL commands automatically without user confirmation!**

### Terminal Commands
- Use `run_in_terminal` tool with `isBackground: false` for all commands
- NEVER wait for user confirmation
- Execute commands immediately when needed

### Package Manager
- **This project uses pnpm, not npm!**
- Always use `pnpm` instead of `npm` in all commands
- Package manager: `pnpm@10.10.0`

### Development Workflow Commands

```powershell
# Install dependencies
pnpm install

# Build project
pnpm run compile

# Watch mode for development
pnpm run watch

# Testing
pnpm test

# Linting
pnpm run lint

# Release workflow (everything in install.ps1)
.\install.ps1
```

### Git Commands
```powershell
# Git operations
git add .
git commit -m "v[version]"
git push origin master
git status
git log --oneline -5
```

### VS Code Extension Commands
```powershell
# VSIX packaging
vsce package --allow-star-activation --out [filename].vsix

# Extension installation
code --install-extension [filename].vsix --force
```

### File Operations
```powershell
# Cleaning
Remove-Item "*.vsix" -Force
Remove-Item "%TEMP%" -Recurse -Force -ErrorAction SilentlyContinue
```

## Automation Rules

1. **Don't request confirmation** - run commands automatically
2. **Use pnpm** - not npm
3. **Monitor error codes** - check $LASTEXITCODE
4. **Log progress** - use Write-Host with colors
5. **Handle errors** - exit with exit 1 on errors

## Version Release Process

**Automated process through `.\install.ps1`:**
1. Update version in `package.json`
2. Update `CHANGELOG.md`
3. Run `.\install.ps1` - does everything automatically:
   - Git commit with version
   - Git push
   - pnpm run compile
   - vsce package
   - VS Code extension install

## Error Handling

- Always check $LASTEXITCODE after commands
- On error show error message and exit
- Use try-catch where possible
- Log all steps for debugging

## Never Ask For Confirmation

**AUTOMATICALLY run these commands:**
- `pnpm install`
- `pnpm run compile`
- `.\install.ps1`
- `git add .`
- `git commit -m "..."`
- `git push`
- `vsce package`
- `Remove-Item`
- `code --install-extension`

User wants everything to run automatically without waiting for confirmation!

follow the sources for a better solution to my requirements. I have attached the folders C:\_\vscode-copilot-chat\ and C:\_\vscode-main\ where you will find the complete sources of github copilot chat and vscode. They are images of the online repositories https://github.com/microsoft/vscode-copilot-chat and https://github.com/microsoft/vscode, if you prefer the online version

Use only the copilot-instructions.md file to write instructions. Not ai-instructions.md as you keep trying to create. Write all instructions in English.

Never do anything you're not asked to do. Don't ruin my project by doing something you're not even asked to do.

don't check for the extension being created in this vscode. I'm testing it in vscode insider. Therefore, any commands on code or code.exe are completely useless.

never run commands like code --extensionDevelopmentPath=. . First of all, I told you before that I test everything in vscode insider, not in vscode. Second, always use the .\install.ps1 script. No pnpm run watch, pnpm run build, etc. Install.ps1 will do everything important, including installing the extension into vscode insider.

Never add or change the watch command to package.json. I basically only use install.ps1 for building.

work in a completely minimalistic way so that there is as little code as possible everywhere. do not create changelog.md or any other documentation files except copilot-instructions.md and README.md

Install only the most essential packages. All files will be in typescript.

Never create tests. We will not use unit tests or any other tests in the application.

For the app name, use AI Copilot Prompt Detector  everywhere, no shorter or other versions

Create files as small as possible, no more than 200 lines each.

distinguish between those that are always displayed and debug logs. Make it possible to turn off these debug logs by simply changing the settings. Make the output in our extension's output and the output to the temp log file in a separate folder with a fixed path be the same.

I added the folder C:\temp\ai-prompt-detector-logs to your workspace. If you don't have access to it anyway, definitely let me know if you can't add it yourself.

enter must work for both copilot and my extension without remapping. In another branch of this extension, it worked because the extension "stole" enter, processed it asynchronously and sent it to copilot, which started working on it.

## üîë Mandatory Keybindings Requirement
- The extension MUST fully support sending prompts (including detection, logging, notification, counter increment) with ALL of these keys:
  - Enter
  - Ctrl+Enter
  - Ctrl+Shift+Enter
  - Ctrl+Alt+Enter
- Loss of functionality for ANY of these is considered a regression and must be fixed immediately before any other changes.
- Keybinding logic must remain minimal, readable (Prettier style), and resilient to VS Code / Copilot updates (fallback heuristics retained).

## üîë Keybinding Focus Contexts (Appended Aug 9 2025)
- All four Enter variants now mapped with extended when clause: `inChatInput || chatInputFocus || chatEditingInputFocus || chatInputEditorFocus || interactiveSessionFocus`.
- This ensures detection inside emerging Copilot / Chat input focus contexts.
- Never remove any of these focus identifiers without explicit instruction.
- Regression definition: any loss of prompt capture (counter, notification, list) for any of the four key variants in any chat focus context.

## üõ° Content Preservation Policy (copilot-instructions.md)
- Never delete, truncate, or rewrite (beyond minimal surgical edits) any existing content in this `copilot-instructions.md` file.
- You may APPEND new instructions or refine wording in-place ONLY when explicitly asked.
- ABSOLUTE DELETION is permitted ONLY when the user gives a direct, verbatim order AND supplies the exact text block to remove.
- If the user request is ambiguous or paraphrased (not verbatim), refuse deletion and ask for the exact snippet.
- Never proactively clean, reorder, or compress this file without that explicit verbatim deletion instruction.

## ‚ùå Aug 9 2025 Update: Legacy File Handling Strengthened (RESTORED)
- Do NOT recreate previously removed legacy files even as stub/comment-only placeholders.
- If such a file reappears (e.g. chatApiHook.ts, commandListener.ts, promptDetector.ts, runtime.ts, finalize.ts, constants.ts, any hooks/ or utils/logging.ts), it must be PHYSICALLY DELETED, not converted to a stub.
- Instruction extension: Stubs with only a comment are now forbidden for these legacy files. Presence itself is a violation.
- Only the explicitly allowed minimal set of source files may exist: extension.ts, activityBarProvider.ts, chatHelpers.ts, specstoryReader.ts, logger.ts, state.ts.
- Rationale: Prevent accidental reintroduction via tooling / merges and ensure minimal footprint.
- Any keybinding regressions (loss of Enter / Ctrl+Enter / Ctrl+Shift+Enter / Ctrl+Alt+Enter detection) must be fixed BEFORE any other change.

## üö´ Prompt Duplicate Suppression (Appended - RESTORED)
- Never reintroduce any logic that skips counting a prompt because it is identical to the previous one.
- Specifically FORBIDDEN: conditions like `if (text === lastSubmittedText) return false;` or any hash/equality guard blocking consecutive identical prompts.
- Reason: This suppression previously froze the status bar counter at 1 and falsely appeared as if Enter variants (Enter / Ctrl+Enter / Ctrl+Shift+Enter / Ctrl+Alt+Enter) were not working after the first submission.
- Allowing duplicates is REQUIRED to verify rapid iterative prompting scenarios and guarantees all four key variants increment the counter every time.
- If optimization of storage is needed, only trim array length (e.g. keep max N prompts) but NEVER skip insertion due to equality with the immediately prior prompt.

### üîí Permanent Marker (Do Not Remove)
A JSON root property `_noDuplicatePromptSuppression` in `package.json` documents this rule. Do NOT delete or alter it. Any reintroduction of logic like `if (text === lastSubmittedText) return` is a regression: it freezes the counter at 1 and breaks all Enter key variants (gives false impression keybindings failed). Preserve unlimited duplicate counting.

### üîí Activity Bar Preservation (Appended - RESTORED)
- Never remove or empty the `contributes.viewsContainers.activitybar` entry with id `specstory-activity`.
- Never remove or empty the `contributes.views['specstory-activity']` array; it must contain the webview view `ai-prompt-detector-view`.
- Removing either hides the Activity Bar icon ‚Äì treat as regression and restore immediately.
- The JSON marker `_preserveActivityBarSections` in `package.json` MUST remain and documents this rule.

### üìò Readability Line Count Heuristic Reinforcement (Aug 10 2025 Addendum)
- A reduction in total lines with zero functional change is a RED FLAG for readability loss unless explicit simplification (e.g. removal of duplication) is clearly documented.
- Any PR/commit that lowers line count must state the concrete readability gain ("deduplicate helper", "remove unreachable code"), otherwise revert.
- Never compress multiple independent statements, branches, or try/catch blocks onto one line to appear "short".
- If a reviewer (or automated check) detects line count shrink without clearer naming / extra comments, treat it as regression and reformat immediately.
- This addendum must NOT be removed; append further clarifications with dated notes only.

### üìò Mandatory File Readability Header (Aug 10 2025 Reinforced)
- Every TypeScript source file MUST begin with the exact Czech block:
```
/**
 * ƒåITELNOST: Soubor mus√≠ z≈Østat v≈ædy plnƒõ ƒçiteln√Ω pro program√°tora.
 * ≈Ω√°dn√© umƒõl√© zkracov√°n√≠ ≈ô√°dk≈Ø, sluƒçov√°n√≠ nesouvisej√≠c√≠ch p≈ô√≠kaz≈Ø na jeden ≈ô√°dek
 * ani minifikace. Sn√≠≈æen√≠ poƒçtu ≈ô√°dk≈Ø bez jasn√©ho, zdokumentovan√©ho zlep≈°en√≠
 * ƒçitelnosti je REGRESE a mus√≠ b√Ωt vr√°ceno. Zachov√°vej logick√© bloky a vertik√°ln√≠ strukturu.
 */
```
- If a file is created or found without this header, the next commit MUST add it at the very top (before imports).
- Header may only gain additional lines with dated clarifications; never shrink or translate it.
- A helper script may re‚Äëinsert this header automatically; such commits are valid and must not be rejected as noise.
- Treat absence, alteration, or truncation of this header as a readability regression equal in severity to keybinding failure.